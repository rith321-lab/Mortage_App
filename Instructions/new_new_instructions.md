I am assuming you will choose the recommended path: TypeORM for the database. If you choose differently, you must adapt this PRD and the instructions accordingly.

# Product Requirements Document: AI-Driven Mortgage Underwriting Platform

**1. Introduction**

This document outlines the requirements for an AI-driven mortgage underwriting platform designed to streamline the pre-approval process for both home buyers and lenders. The platform will provide a single, unified application for borrowers, automate document verification and data extraction, perform AI-driven risk assessment, and deliver fully packaged applications to lenders.

**2. Goals**

*   Provide a user-friendly, single application process for borrowers, eliminating the need to fill out multiple forms for different lenders.
*   Automate document upload, verification, and data extraction using OCR and AI.
*   Perform AI-powered underwriting analysis based on Fannie Mae guidelines.
*   Generate pre-approval decisions within 24 hours.
*   Deliver complete, verified application packages to lenders.
*   Increase efficiency and reduce processing time for both borrowers and lenders.
*   Ensure data security and compliance with relevant regulations (GDPR, CCPA, etc.).

**3. Target Audience**

*   **Home Buyers:** Individuals seeking pre-approval for a mortgage.
*   **Loan Officers/Lenders:** Mortgage professionals who need to evaluate applications and make lending decisions.
* **System Administrators:**  Individuals responsible for maintaining the platform.

**4. Release Criteria**

The MVP (Minimum Viable Product) will be considered ready for release when:

*   Users can sign up and log in securely using Supabase Auth.
*   Users can complete and submit a single mortgage application form (all sections).
*   Users can upload required documents.
*   The system can store user data and documents securely.
*   The backend API can receive and process application data.
*   Basic error handling and user feedback are implemented.
*   The application is deployed to a staging environment and passes basic functionality tests.

**Subsequent releases will add:**

*   Full AI underwriting engine.
*   Integration with lender systems.
*   Document OCR and verification.
*   Digital signature integration.
*   Advanced analytics and reporting.
*   Multilingual support.
*   MFA (Multi-Factor Authentication)

**5. User Stories**

*   As a home buyer, I want to easily create an account and log in so that I can start my mortgage application.
*   As a home buyer, I want to fill out a single, comprehensive application form so that I don't have to repeat the process for multiple lenders.
*   As a home buyer, I want to be able to upload my documents securely and easily.
*   As a home buyer, I want to track the status of my application in real-time.
*   As a home buyer, I want to receive multiple loan offers from different lenders.
*   As a loan officer, I want to receive complete and verified application packages.
*   As a loan officer, I want to see an AI-powered risk assessment for each application.
*   As a loan officer, I want to be able to easily communicate with applicants.
*   As a system administrator, I want to be able to monitor system performance and security.
*   As a system administrator, I want to be able to manage user accounts and roles.

**6. Features**

**6.1. User Authentication and Authorization (using Supabase Auth)**

*   **Sign Up/Sign In:** Email/password signup and login. (Social login *optional* for later).
*   **Password Reset:**  Standard "forgot password" flow.
*   **Multi-Factor Authentication (MFA):** *Not in MVP, but planned for later*. 
*   **Role-Based Access Control (RBAC):**  Users will have roles (e.g., 'buyer', 'lender', 'admin') that determine their access to features and data.  This will be implemented using Supabase Auth's metadata and custom backend middleware.
* **Session Management:** Use Supabase to persist the session state

**6.2. Mortgage Application Form**

*   **Sections:**
    *   Personal Information (name, contact, SSN, DOB)
    *   Property Details (address, type, purchase price, down payment)
    *   Loan Details (amount, type, term)
    *   Employment History (employer, position, income, duration)
    *   Assets (checking/savings, investments, etc.)
    *   Liabilities (credit cards, loans, etc.)
    *   Consent (for credit checks, etc.)

*   **Validation:**  Use Zod schemas for both client-side (React Hook Form) and server-side validation.

*   **Progress Saving:**  Auto-save form progress (using local storage or backend API).

*   **Form Navigation:** Clear step-by-step navigation (e.g., using a progress bar or stepper component).

**6.3. Document Upload**

*   **Supported File Types:** PDF, JPG, PNG, TIFF.
*   **File Size Limit:** 50MB per file.
*   **Upload Mechanism:** Use pre-signed URLs generated by the backend (using AWS S3).  The frontend should *not* directly upload to Supabase Storage.
*   **Progress Indication:** Display upload progress to the user.
*   **Error Handling:** Handle upload failures gracefully (e.g., network errors, file size limits).
*   **Document Storage:** Store documents securely in AWS S3. The backend will manage access control.
*   **Document Preview** Display documents in the browser using an appropriate viewer.

**6.4. Backend (API)**

*   **Framework:** Express.js
*   **Database:** PostgreSQL (accessed via TypeORM)
*   **ORM:** TypeORM (This is a **CRITICAL** decision.  We are using TypeORM entities and migrations.)
*   **API Style:** RESTful
*   **Authentication:** Supabase Auth (JWT verification).  Backend API endpoints *must* verify the JWT sent by the frontend.
*   **Authorization:** Role-based access control (RBAC).
*   **Endpoints:**
    *   `/api/auth/*` (handled by Supabase Auth, but we'll need middleware to connect it to our user data)
    *   `/api/applications` (create, read, update, delete applications)
    *   `/api/applications/:id/documents` (upload, download, list, delete documents)
    *   `/api/dashboard` (for fetching user-specific dashboard data)
    *   `/api/admin/*` (for administrative functions - user management, etc.)
    * ... (other endpoints as needed)

**6.5. AI Underwriting Engine (Post-MVP)**

*   Integrate with a third-party AI/ML service (e.g., AWS Textract, Google Cloud Document AI, or a specialized mortgage underwriting API).
*   Perform risk assessment based on Fannie Mae guidelines.
*   Generate pre-approval decisions and recommendations.

**6.6. User Dashboard**

*   **Home Buyer Dashboard:**
    *   Application status tracking.
    *   List of submitted applications.
    *   Document upload status.
    *   Loan offers (once available).
    *   Communication with loan officers (future feature).
*   **Lender Dashboard:**
    *   List of incoming applications.
    *   AI-powered risk assessment.
    *   Document viewing.
    *   Loan offer creation/management.
    *   Communication with applicants (future feature).

**6.7. Notifications**

*   Real-time updates on application status (using Supabase Realtime or a similar technology).
*   Email notifications (using a service like SendGrid or AWS SES).
*   SMS notifications (optional, for later).

**6.8. Settings**

*   **User Profile:** Update personal information, change password, manage notification preferences.
*   **Security Settings:** Manage MFA (once implemented).

**7. Data Model**

*   **Users:** `id` (UUID), `email` (unique), `passwordHash`, `firstName`, `lastName`, `phone`, `role` (enum), `createdAt`, `updatedAt`, `resetToken` (nullable), `resetTokenExpires` (nullable).
*   **MortgageApplications:** `id` (UUID), `userId` (FK to Users), `status` (enum), `propertyDetails` (separate table), `loanDetails` (separate table), `borrowerDetails` (separate table, or combine some fields into `Users`), `employmentHistory` (separate table), `assets` (separate table), `liabilities` (separate table), `createdAt`, `updatedAt`, `submittedAt`.
*   **Documents:** `id` (UUID), `applicationId` (FK to MortgageApplications), `type` (enum), `name`, `filePath` (S3 key), `fileSize`, `mimeType`, `uploadedBy` (FK to Users), `status` ('pending', 'verified', 'rejected'), `verifiedAt` (nullable), `verifiedBy` (nullable, FK to Users).
*   **Properties:** (separate table for property details - normalize the data).
*   **BorrowerIncome:** (separate table, multiple income sources per application)
*   **AI_Analysis:** (separate table for storing AI analysis results).

**8. Security Considerations**

*   **Authentication:** Supabase Auth for user authentication.
*   **Authorization:** Role-Based Access Control (RBAC) using Supabase and custom middleware.
*   **Data Encryption:** Data at rest and in transit must be encrypted.
*   **Input Validation:** Zod schemas for all API requests and form submissions.
*   **Rate Limiting:** Implement rate limiting to prevent abuse.
*   **Regular Security Audits:**  Conduct regular security audits and penetration testing.
*   **Compliance:** Adhere to relevant data privacy regulations (GDPR, CCPA, etc.).

**9. Performance and Scalability**

*   **Scalable Infrastructure:** Use a cloud provider (AWS, Azure, Google Cloud) to ensure scalability.
*   **Load Balancing:** Distribute traffic across multiple servers.
*   **Caching:** Implement caching to reduce database load and improve response times.
*   **Optimized Database Queries:** Use efficient database queries and indexing.
*   **Code Splitting and Lazy Loading (Frontend):**  Minimize initial load time.

**10. Testing**

*   **Unit Tests:** Test individual components and functions.
*   **Integration Tests:** Test the interaction between different parts of the application.
*   **End-to-End Tests:** Simulate user flows and test the entire application.
*   **Performance Testing:**  Ensure the application can handle expected load.
*   **Security Testing:**  Regular vulnerability scans and penetration testing.

**11. Deployment**

*   **CI/CD:**  Automated build and deployment pipeline.
*   **Containerization:**  Use Docker for consistent deployments.
*   **Infrastructure as Code (IaC):** Use tools like Terraform to manage infrastructure.

**12. Monitoring and Logging**

*   **Real-time Monitoring:** Track key metrics (e.g., application processing time, error rates).
*   **Alerting:**  Set up alerts for critical issues.
*   **Logging:** Comprehensive logging for debugging and auditing.

**13. Future Considerations (Out of Scope for MVP)**

*   AI-driven loan product recommendations.
*   Integration with additional lenders and financial institutions.
*   Advanced analytics and reporting for lenders.
*   Chat functionality for real-time communication between borrowers and lenders.

**This PRD provides a clear roadmap for the development of the AI-Driven Mortgage Underwriting Platform. It outlines the core features, user flows, technical requirements, and security considerations necessary to deliver a successful MVP.**

---

**Instructions for your next steps (VERY IMPORTANT):**

1.  **Confirm Database Choice:**  Tell me *explicitly* if you are choosing TypeORM (recommended) or raw SQL migrations with Supabase.
2.  **Database Schema (TypeORM):** If you chose TypeORM, create entity files for *all* of your tables.  These files should be in `backend/src/entities` (you'll need to create this directory).  Here's an example structure for the `Property` entity (you'll need to adapt it):

    ```typescript
    // backend/src/entities/Property.ts
    import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, JoinColumn } from 'typeorm';
    import { MortgageApplication } from './MortgageApplication'; // You'll create this

    @Entity('properties')
    export class Property {
      @PrimaryGeneratedColumn('uuid')
      id: string;

      @Column()
      address: string;

      @Column()
      city: string;

      @Column({ length: 2 }) // State code
      state: string;

      @Column({ name: 'zip_code' }) // Example of renaming a column
      zipCode: string;

      @Column({
        type: 'enum',
        enum: ['single_family', 'multi_family', 'condo', 'townhouse'],
        name: 'property_type' // Good practice to name enums explicitly
      })
      propertyType: 'single_family' | 'multi_family' | 'condo' | 'townhouse';

      @Column('decimal', { precision: 15, scale: 2 }) // Example of decimal type
      purchasePrice: number;

      @Column('decimal', { precision: 15, scale: 2 })
      downPayment: number;

      @Column('decimal', { precision: 15, scale: 2 })
      estimatedValue: number;

      @Column({
        type: 'enum',
        enum: ['primary', 'secondary', 'investment'],
        name: 'occupancy_type'
      })
        occupancyType: 'primary' | 'secondary' | 'investment';


      @ManyToOne(() => MortgageApplication, application => application.property) // Relationship
      @JoinColumn({ name: 'application_id' }) // Foreign key column name
      application: MortgageApplication;

      // You'll probably want createdAt/updatedAt, but I've omitted for brevity

    }
    ```
    *   You'll need to do this for *every* table, including `MortgageApplication`, `LoanDetails` (rename from `loan_details`), `BorrowerDetails`, `EmploymentHistory`, `Asset`, `Liability`, etc.
    *   Define relationships between entities using `@OneToMany`, `@ManyToOne`, `@OneToOne`, and `@JoinColumn`.  For example, a `MortgageApplication` will have a `@OneToOne` relationship with a `Property`. An `Asset` will have a `@ManyToOne` relationship with a `MortgageApplication`.
    *  Use enum types (like the example above)

3.  **Database Schema (Raw SQL/Supabase):** If you choose raw SQL, create a single, comprehensive SQL file (e.g., `001_initial_schema.sql`) in `backend/supabase/migrations` that defines *all* tables, columns, data types, constraints, and indexes.  *Remove* the conflicting migrations in `backend/src/db/migrations`. *Remove* the `User.ts` file, and all references to TypeORM.

4.  **Authentication:** Refactor your code to use *only* Supabase Auth.  Remove all the `bcrypt` and `jsonwebtoken` code.  Use the `useAuth` hook in your frontend components.

5.  **API Client:** Consolidate your Axios instances into a single instance in `frontend/src/lib/axios.ts`.

6.  **Types:** Create TypeScript interfaces/types for all your data structures.

7.  **Regenerate and Upload:** After making these changes, regenerate and upload a new `repopack-output.txt`.

**Do not proceed to other features until these foundational issues are resolved.** Once these core pieces are in place, we can move on to implementing the other features and API endpoints. I'm here to help guide you through each step.